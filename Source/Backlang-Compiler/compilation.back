import System;
import System.Collections;
import System.Collections.Generic;

using Console::WriteLine as print;

module Test;

enum MirrorKind {
	YAxis,
	XAxis,
	Point
}

//ToDo: implement attributes
@Serializable
@Comparable
struct Vector2 {
	X : i32;
	Y : i32;
}

//ToDo: implement custom macros
@MacroInfo("Add functions for comparing two instances", MacroMode.IdentifierOrCall, containsBody = false, matchAttribute = true)
macro Comparable(node : LNode, context : MacroContext) -> LNode {
	let args : LNodeList = LNodeList::new();
	for i in 0..1 {
		args.Add(node.Args[i]);
	}

	//ToDo: implement comparison functions

	args.Add(body);

	return node.WithArgs(args);
}

//ToDo: implement interfaces
interface ISerializable {
	func Serialize() -> byte[];
	func Deserialize(object : byte[]) -> obj;
}

//ToDo: implement inheritance for struct for interfaces or macro calls
struct Point : Serialize() {
	X : i32;
	Y : i32;
}

implement Point {
	func mirror(other : Point, kind : MirrorKind) -> Point {
		if kind == MirrorKind.YAxis {
			return Point::new(other.X, -other.Y);
		}
		else if kind == MirrorKind.XAxis {
			return Point::new(-other.X, other.Y);
		}
		else if kind == MirrorKind.Point {
			return Point::new(-other.X, -other.Y);
		}
	}

	func add(lhs : Point, rhs : Point) operator -> Point {
		return Point::new(lhs.X + rhs.X, lhs.Y + rhs.Y);
	}

	func sub(lhs : Point, rhs : Point) operator -> Point {
		return Point::new(lhs.X - rhs.X, lhs.Y - rhs.Y);
	}

	func toString() -> string {
		return "X: " + X + " Y: " + Y;
	}
}

implement u8..u64, f64, i16..i64 {
	func someTest() -> SELF {
		#matchCode(somevalue) {
			msg += "Hello";
			let msg : string = concatId(a, b, c);
		}
	}
}

func main() static -> none {
	let msg : string = concatId(a, b, c);
	let name : string = nameof(msg);
	let k = 1.2;

	let s = Point::new();
	let handle = ^s;
	let another = ^s;
	#autofree(handle, another) {
		print(&handle);
	}

	let myChar = 'a';

	switch myChar {
		break case 'b' || 'c': print("It's B!");
		if isAlpha(myChar): {
			print("It's...");
			print("a C!");
		}
		case 'w': break;
		default: print("i dont know what it is :c");
	}

	let mut i = 10;

	while i > 0 {
		i -= 1;
	}
	
	
	let mypoint = Point::new(1, 2);

	msg += "Hello";
	msg -= 'c';
	
	print("something new");

	#quote {
		print(msg);
	}

	return 0;
}

func println(arg : string) static -> none {
	print(msg + "\n");
}

